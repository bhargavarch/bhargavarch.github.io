/**
 * Sticky Table of Contents with Scroll-Spy
 * Highlights current section and provides smooth navigation
 */

class StickyTOC {
  constructor() {
    this.toc = document.getElementById('toc-wrapper');
    this.tocLinks = [];
    this.sections = [];
    this.currentActive = null;
    this.observer = null;

    if (this.toc) {
      this.init();
    }
  }

  init() {
    // Wait for TOC to be populated (it's generated by tocbot)
    setTimeout(() => {
      this.setupStickyBehavior();
      this.setupScrollSpy();
      this.setupSmoothScroll();
    }, 500);
  }

  setupStickyBehavior() {
    if (!this.toc) return;

    // Make TOC sticky
    this.toc.classList.add('sticky-toc');

    // Add collapse/expand for mobile
    const heading = this.toc.querySelector('.panel-heading');
    if (heading && window.innerWidth <= 1200) {
      heading.style.cursor = 'pointer';
      heading.addEventListener('click', () => {
        this.toc.classList.toggle('collapsed');
      });
    }
  }

  setupScrollSpy() {
    // Get all TOC links
    this.tocLinks = Array.from(this.toc.querySelectorAll('a'));

    if (this.tocLinks.length === 0) return;

    // Get all corresponding sections
    this.sections = this.tocLinks.map(link => {
      const id = link.getAttribute('href').substring(1);
      return document.getElementById(id);
    }).filter(section => section !== null);

    // Use Intersection Observer for efficient scroll tracking
    const observerOptions = {
      root: null,
      rootMargin: '-80px 0px -80% 0px', // Trigger when section is near top
      threshold: 0
    };

    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.highlightTOCLink(entry.target.id);
        }
      });
    }, observerOptions);

    // Observe all sections
    this.sections.forEach(section => {
      this.observer.observe(section);
    });
  }

  highlightTOCLink(sectionId) {
    // Remove previous active
    if (this.currentActive) {
      this.currentActive.classList.remove('active');
    }

    // Find and activate corresponding TOC link
    const activeLink = this.tocLinks.find(link => {
      return link.getAttribute('href') === `#${sectionId}`;
    });

    if (activeLink) {
      activeLink.classList.add('active');
      this.currentActive = activeLink;

      // Scroll TOC to show active link (if TOC is scrollable)
      if (this.toc.scrollHeight > this.toc.clientHeight) {
        activeLink.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest'
        });
      }
    }
  }

  setupSmoothScroll() {
    this.tocLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = link.getAttribute('href').substring(1);
        const target = document.getElementById(targetId);

        if (target) {
          // Smooth scroll to target
          target.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });

          // Update URL
          if (history.pushState) {
            history.pushState(null, null, `#${targetId}`);
          }

          // Show toast feedback
          if (window.Toast) {
            window.Toast.info(`Jumped to ${target.textContent.substring(0, 30)}...`, 2000);
          }
        }
      });
    });
  }

  destroy() {
    if (this.observer) {
      this.sections.forEach(section => {
        this.observer.unobserve(section);
      });
    }
  }
}

// Initialize after DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.StickyTOC = new StickyTOC();
});

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = StickyTOC;
}
